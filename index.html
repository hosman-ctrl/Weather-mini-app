<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeatherFlow</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        import { locationManager, init } from 'https://unpkg.com/@telegram-apps/sdk?module';
        window.TelegramSDK = { locationManager, init };
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,300..700,0..1,-25..200" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        :root {
            /* Dynamic weather colors - will be updated by JS */
            --weather-primary: #6750A4;
            --weather-secondary: #FFB2FF;
            --weather-gradient: linear-gradient(135deg, #6750A4 0%, #FFB2FF 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
            --weather-on-gradient: #FFFFFF;
            --weather-on-surface: #1C1B1F;
            
            /* Animation Speeds */
            --animation-slow: 800ms;
            --animation-medium: 400ms;
            --animation-fast: 200ms;
            
            /* Elevation */
            --elevation-1: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            --elevation-2: 0px 2px 6px 2px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            --elevation-3: 0px 4px 8px 4px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            
            /* Shapes */
            --shape-extra-large: 28px;
            --shape-large: 20px;
            --shape-medium: 16px;
        }

        body {
            background: var(--weather-gradient);
            color: var(--weather-on-gradient);
            min-height: 100vh;
            transition: background var(--animation-slow) ease;
            overflow-x: hidden;
            position: relative;
            will-change: background;
        }

        /* Loading Screen with Grey Background */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #808080 !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            transition: opacity var(--animation-medium) ease;
        }

        .loading-text {
            font-size: 16px;
            font-weight: 500;
            color: white;
            letter-spacing: 0.5px;
            opacity: 0.9;
            margin-top: 20px;
            animation: text-pulse 2s ease-in-out infinite;
        }

        @keyframes text-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Canvas Container - Fixed 2cm size */
        .canvas-container {
            width: 2cm !important;
            height: 2cm !important;
            position: relative !important;
        }

        #wigglyCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Weather Elements Container */
        .weather-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        /* Enhanced Sun Element with Static Rays */
        .sun {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FF9800, #FF5722);
            box-shadow: 
                0 0 60px rgba(255, 152, 0, 0.8),
                0 0 100px rgba(255, 152, 0, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            transition: all 1s ease;
            will-change: transform, box-shadow, background;
        }

        .sun::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle at center, rgba(255, 235, 59, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: -1;
            animation: sun-glow 3s ease-in-out infinite;
        }

        .sun-rays {
            position: absolute;
            width: 100%;
            height: 100%;
            animation: sun-pulse 3s ease-in-out infinite;
        }

        .sun-ray {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 3px;
            height: 40px;
            background: linear-gradient(to top, rgba(255, 152, 0, 0.8), transparent);
            border-radius: 2px;
            transform-origin: center 70px;
            opacity: 0.7;
        }

        @keyframes sun-glow {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes sun-pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        /* Moon Element */
        .moon {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #E0E0E0, #B0B0B0);
            box-shadow: 
                0 0 40px rgba(224, 224, 224, 0.6),
                0 0 80px rgba(224, 224, 224, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            transition: all 1s ease;
            will-change: transform, box-shadow, background;
            animation: moon-pulse 4s ease-in-out infinite;
        }

        @keyframes moon-pulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
        }

        /* Cloud Element */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50px;
            filter: blur(2px);
            transition: all 3s ease;
            will-change: transform, opacity;
        }

        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            filter: blur(2px);
        }

        /* Enhanced Rain Element - Blue Droplets */
        .rain-drop {
            position: absolute;
            width: 4px;
            height: 30px;
            background: linear-gradient(to bottom, transparent, #42A5F5 80%, #2196F3);
            border-radius: 2px;
            transform: translateZ(0);
            filter: drop-shadow(0 0 3px rgba(33, 150, 243, 0.5));
            will-change: transform, opacity;
        }

        /* Snow Element */
        .snow-flake {
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            filter: blur(1px) drop-shadow(0 0 2px rgba(255, 255, 255, 0.5));
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        /* Lightning Effect */
        .lightning {
            position: absolute;
            width: 4px;
            height: 60px;
            background: linear-gradient(to bottom, transparent, #FFEB3B, transparent);
            border-radius: 2px;
            filter: blur(1px) drop-shadow(0 0 10px #FFEB3B);
            opacity: 0;
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        /* Star Element */
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 6px white;
            animation: twinkle 3s infinite alternate;
            will-change: opacity;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Typography with Rounded Clear Font */
        .display-large {
            font-size: 57px;
            font-weight: 400;
            line-height: 64px;
            letter-spacing: -0.25px;
            font-feature-settings: 'ss01' on;
        }

        .headline-large {
            font-size: 32px;
            font-weight: 400;
            line-height: 40px;
            letter-spacing: 0;
            font-feature-settings: 'ss01' on;
        }

        .headline-medium {
            font-size: 28px;
            font-weight: 400;
            line-height: 36px;
            letter-spacing: 0;
            font-feature-settings: 'ss01' on;
        }

        .title-large {
            font-size: 22px;
            font-weight: 400;
            line-height: 28px;
            letter-spacing: 0;
            font-feature-settings: 'ss01' on;
        }

        .title-medium {
            font-size: 16px;
            font-weight: 500;
            line-height: 24px;
            letter-spacing: 0.15px;
            font-feature-settings: 'ss01' on;
        }

        .body-large {
            font-size: 16px;
            font-weight: 400;
            line-height: 24px;
            letter-spacing: 0.5px;
            font-feature-settings: 'ss01' on;
        }

        .body-medium {
            font-size: 14px;
            font-weight: 400;
            line-height: 20px;
            letter-spacing: 0.25px;
            font-feature-settings: 'ss01' on;
        }

        .label-large {
            font-size: 14px;
            font-weight: 500;
            line-height: 20px;
            letter-spacing: 0.1px;
            font-feature-settings: 'ss01' on;
        }

        /* Dynamic Text Colors */
        .on-gradient {
            color: var(--weather-on-gradient) !important;
        }

        .on-surface {
            color: var(--weather-on-surface) !important;
        }

        /* Retractable Search Bar */
        .search-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .search-pill {
            width: 2cm;
            background: var(--weather-surface);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 100px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .search-pill.expanded {
            width: 250px;
        }

        .search-input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 400;
            color: var(--weather-on-surface);
            outline: none;
            font-family: inherit;
            width: 0;
            opacity: 0;
            transition: width 0.3s ease, opacity 0.3s ease;
        }

        .search-pill.expanded .search-input {
            width: 100%;
            opacity: 1;
        }

        .search-input::placeholder {
            color: rgba(28, 27, 31, 0.6);
        }

        .search-icon {
            color: var(--weather-primary);
            font-size: 18px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .search-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--weather-primary);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--elevation-2);
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            will-change: transform;
        }

        .search-button:hover {
            transform: scale(1.05);
        }

        /* Bottom Switch Pill */
        .bottom-switch {
            position: fixed;
            bottom: 38px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--weather-surface);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 100px;
            padding: 6px;
            display: flex;
            gap: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-3);
            z-index: 100;
            will-change: transform, opacity;
        }

        .switch-option {
            padding: 10px 24px;
            border: none;
            background: transparent;
            border-radius: 100px;
            font-size: 14px;
            font-weight: 500;
            color: rgba(28, 27, 31, 0.6);
            cursor: pointer;
            transition: all var(--animation-medium) ease;
            font-family: inherit;
            min-width: 100px;
            text-align: center;
        }

        .switch-option.active {
            background: var(--weather-primary);
            color: var(--weather-on-gradient);
            box-shadow: var(--elevation-1);
        }

        /* Main Container */
        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 80px 20px 100px 20px;
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Map Tab Styling */
        #mapTab {
            width: 100%;
            height: calc(100vh - 180px);
            border-radius: var(--shape-extra-large);
            overflow: hidden;
            margin-top: 10px;
            box-shadow: var(--elevation-2);
            background: white;
            position: relative;
            transition: all var(--animation-medium) ease;
        }

        #weatherMap {
            width: 100%;
            height: 100%;
            border-radius: var(--shape-extra-large);
        }

        /* Enhanced Map Styling */
        .weather-marker {
            background: white;
            border-radius: 12px;
            border: 2px solid var(--weather-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            width: 70px;
            height: 70px;
            cursor: pointer;
            padding: 8px;
            transition: all 0.3s ease;
        }

        .weather-marker:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .weather-marker.current {
            border-color: #FF5722;
            background: linear-gradient(135deg, #FF5722, #FF9800);
        }

        .weather-marker.current span,
        .weather-marker.current .marker-temp {
            color: white !important;
        }

        .marker-temp {
            font-size: 16px;
            font-weight: 600;
            color: var(--weather-primary);
            margin-top: 4px;
        }

        .leaflet-popup-content {
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            min-width: 180px;
        }

        .leaflet-popup-content b {
            color: var(--weather-primary);
            font-size: 16px;
        }

        /* Fullscreen map styles */
        .map-fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 10000 !important;
            border-radius: 0 !important;
            margin-top: 0 !important;
        }

        .map-back-button {
            position: fixed;
            top: calc(20px + env(safe-area-inset-top));
            left: 20px;
            z-index: 10001;
            background: var(--weather-surface);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--elevation-3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all var(--animation-medium) ease;
        }

        .map-back-button:hover {
            transform: scale(1.1);
        }

        .map-back-button span {
            color: var(--weather-primary);
            font-size: 24px;
        }

        body.map-mode {
            overflow: hidden;
        }

        /* Location Section */
        .location-section {
            text-align: center;
            margin-bottom: 32px;
            position: relative;
        }

        .location-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .location-name {
            font-size: 32px;
            font-weight: 400;
            margin: 0;
            line-height: 1.2;
        }

        .location-details {
            display: flex;
            justify-content: center;
            gap: 16px;
            font-size: 14px;
            font-weight: 400;
            opacity: 0.9;
        }

        /* Weather Cards */
        .weather-card {
            background: var(--weather-surface);
            border-radius: var(--shape-extra-large);
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-2);
            transition: all var(--animation-medium) ease;
            will-change: transform, opacity;
        }

        .weather-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .temperature-section {
            display: flex;
            flex-direction: column;
        }

        .temperature {
            font-size: 72px;
            font-weight: 300;
            line-height: 1;
            margin-bottom: 4px;
            display: flex;
            align-items: flex-start;
            letter-spacing: -2px;
        }

        .temp-unit {
            font-size: 24px;
            margin-top: 12px;
            margin-left: 4px;
            font-weight: 400;
        }

        .weather-description {
            font-size: 18px;
            font-weight: 400;
            text-transform: capitalize;
            opacity: 0.9;
        }

        .weather-icon {
            font-size: 72px;
            color: var(--weather-primary);
        }

        /* Weather Grid */
        .weather-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 24px;
        }

        .weather-item {
            background: rgba(103, 80, 164, 0.08);
            border-radius: var(--shape-large);
            padding: 16px;
            text-align: center;
            transition: all var(--animation-fast) ease;
            border: 1px solid rgba(103, 80, 164, 0.1);
            will-change: transform;
        }

        .weather-item:hover {
            transform: translateY(-2px);
            background: rgba(103, 80, 164, 0.12);
        }

        .weather-icon-small {
            font-size: 20px;
            margin-bottom: 8px;
            color: var(--weather-primary);
        }

        .weather-label {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }

        .weather-value {
            font-size: 20px;
            font-weight: 400;
            line-height: 1.2;
        }

        .weather-unit {
            font-size: 12px;
            font-weight: 400;
            opacity: 0.7;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fade-in var(--animation-medium) ease;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tab-content.active {
            display: block;
        }

        /* Hourly Forecast */
        .hourly-forecast {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 20px 0;
            margin-bottom: 24px;
            scrollbar-width: none;
        }

        .hourly-forecast::-webkit-scrollbar {
            display: none;
        }

        .hour-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--weather-surface);
            padding: 16px;
            border-radius: var(--shape-large);
            min-width: 80px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-1);
            transition: all var(--animation-fast) ease;
            flex-shrink: 0;
            will-change: transform;
        }

        .hour-time {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            opacity: 0.8;
        }

        .hour-temp {
            font-size: 20px;
            font-weight: 400;
            margin: 8px 0;
        }

        /* History Tab - Improved */
        .history-controls {
            background: var(--weather-surface);
            border-radius: var(--shape-extra-large);
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-1);
        }

        .date-picker-container {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
            flex-direction: column;
        }

        .date-input {
            flex: 1;
            padding: 16px;
            background: rgba(103, 80, 164, 0.08);
            border: 2px solid rgba(103, 80, 164, 0.2);
            border-radius: var(--shape-medium);
            font-size: 16px;
            font-weight: 400;
            color: var(--weather-on-surface);
            transition: all var(--animation-medium) ease;
            font-family: inherit;
            width: 100%;
        }

        .date-input:focus {
            outline: none;
            border-color: var(--weather-primary);
        }

        .history-button {
            padding: 16px 24px;
            background: var(--weather-primary);
            border: none;
            border-radius: var(--shape-medium);
            color: var(--weather-on-gradient);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--animation-medium) ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
        }

        .history-button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .history-button:active {
            transform: translateY(0);
        }

        .historical-card {
            background: var(--weather-surface);
            border-radius: var(--shape-extra-large);
            padding: 24px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-1);
            animation: fade-in 0.5s ease;
        }

        .historical-date {
            font-size: 18px;
            font-weight: 500;
            color: var(--weather-primary);
            margin-bottom: 24px;
            text-align: center;
        }

        .historical-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 24px;
        }

        .historical-stat {
            text-align: center;
        }

        .historical-stat-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--weather-on-surface);
            opacity: 0.7;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .historical-stat-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--weather-primary);
        }

        .historical-stat-unit {
            font-size: 14px;
            font-weight: 400;
            color: var(--weather-on-surface);
            opacity: 0.7;
        }

        /* Modules */
        .modules-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .module-card {
            background: var(--weather-surface);
            border-radius: var(--shape-large);
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-1);
            transition: all var(--animation-medium) ease;
            will-change: transform;
        }

        .module-card:hover {
            transform: translateY(-4px);
        }

        .module-icon {
            font-size: 24px;
            margin-bottom: 12px;
            color: var(--weather-primary);
        }

        .module-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }

        .module-value {
            font-size: 28px;
            font-weight: 400;
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .module-unit {
            font-size: 14px;
            font-weight: 400;
            opacity: 0.7;
        }

        /* Error State */
        .error-state {
            background: var(--weather-surface);
            border-radius: var(--shape-extra-large);
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--elevation-1);
        }

        .error-icon {
            font-size: 48px;
            color: #FF5252;
            margin-bottom: 20px;
        }

        .error-title {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 12px;
        }

        .error-message {
            opacity: 0.8;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .retry-button {
            padding: 12px 24px;
            background: var(--weather-primary);
            border: none;
            border-radius: var(--shape-medium);
            color: var(--weather-on-gradient);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--animation-medium) ease;
        }

        .retry-button:hover {
            opacity: 0.9;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .container {
                padding: 80px 16px 100px 16px;
            }
            
            .temperature {
                font-size: 64px;
            }
            
            .weather-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            
            .historical-stats {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .modules-grid {
                grid-template-columns: 1fr;
            }
            
            .switch-option {
                padding: 8px 16px;
                min-width: 70px;
                font-size: 13px;
            }
            
            .search-pill.expanded {
                width: 200px;
            }
            
            #mapTab {
                height: calc(100vh - 160px);
            }
            
            .weather-marker {
                width: 60px;
                height: 60px;
            }
            
            .marker-temp {
                font-size: 14px;
            }
        }

        /* Weather Background Classes */
        body.clear-day {
            --weather-primary: #FFB74D;
            --weather-secondary: #42A5F5;
            --weather-gradient: linear-gradient(135deg, #FFB74D 0%, #42A5F5 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.clear-night {
            --weather-primary: #1A237E;
            --weather-secondary: #0D47A1;
            --weather-gradient: linear-gradient(135deg, #1A237E 0%, #0D47A1 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.partly-cloudy-day {
            --weather-primary: #78909C;
            --weather-secondary: #B0BEC5;
            --weather-gradient: linear-gradient(135deg, #78909C 0%, #B0BEC5 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.partly-cloudy-night {
            --weather-primary: #455A64;
            --weather-secondary: #607D8B;
            --weather-gradient: linear-gradient(135deg, #455A64 0%, #607D8B 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.cloudy {
            --weather-primary: #607D8B;
            --weather-secondary: #455A64;
            --weather-gradient: linear-gradient(135deg, #607D8B 0%, #455A64 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.rainy {
            --weather-primary: #42A5F5;
            --weather-secondary: #2196F3;
            --weather-gradient: linear-gradient(135deg, #42A5F5 0%, #2196F3 100%);
            --weather-surface: rgba(66, 165, 245, 0.95);
        }

        body.snowy {
            --weather-primary: #E3F2FD;
            --weather-secondary: #BBDEFB;
            --weather-gradient: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            --weather-on-gradient: #1C1B1F;
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.stormy {
            --weather-primary: #5C6BC0;
            --weather-secondary: #3949AB;
            --weather-gradient: linear-gradient(135deg, #5C6BC0 0%, #3949AB 100%);
            --weather-surface: rgba(92, 107, 192, 0.95);
        }

        body.foggy {
            --weather-primary: #CFD8DC;
            --weather-secondary: #B0BEC5;
            --weather-gradient: linear-gradient(135deg, #CFD8DC 0%, #B0BEC5 100%);
            --weather-on-gradient: #1C1B1F;
            --weather-surface: rgba(255, 255, 255, 0.95);
        }

        body.thunderstorm {
            --weather-primary: #512DA8;
            --weather-secondary: #311B92;
            --weather-gradient: linear-gradient(135deg, #512DA8 0%, #311B92 100%);
            --weather-surface: rgba(81, 45, 168, 0.95);
        }
    </style>
</head>
<body class="clear-day">
    <!-- Loading Screen with Wiggly Ring -->
    <div class="loading-screen" id="loadingScreen" style="background: #808080;">
        <div class="canvas-container">
            <canvas id="wigglyCanvas"></canvas>
        </div>
        <div class="loading-text" id="loadingText">Detecting your location...</div>
    </div>

    <!-- Weather Elements Container -->
    <div class="weather-elements" id="weatherElements"></div>

    <!-- Retractable Search Bar -->
    <div class="search-container">
        <div class="search-pill" id="searchPill">
            <span class="material-symbols-rounded search-icon" id="searchIcon">search</span>
            <input type="text" class="search-input" id="searchInput" placeholder="Search location">
        </div>
        <button class="search-button" id="searchButton">
            <span class="material-symbols-rounded">arrow_forward</span>
        </button>
    </div>

    <!-- Main App Content -->
    <div class="container" id="appContainer" style="display: none;">
        <!-- Location Section -->
        <div class="location-section">
            <div class="location-header">
                <span class="material-symbols-rounded weather-icon-small">location_on</span>
                <h1 class="headline-medium on-gradient" id="locationName">Loading...</h1>
            </div>
            <div class="location-details on-gradient">
                <span id="elevation">-- m</span>
                <span>•</span>
                <span id="timezone">--</span>
            </div>
        </div>

        <!-- Current Weather Card -->
        <div class="weather-card" id="currentWeather">
            <div class="weather-main">
                <div class="temperature-section">
                    <div class="temperature on-surface">
                        <span id="currentTemp">--</span>
                        <span class="temp-unit on-surface">°C</span>
                    </div>
                    <div class="weather-description on-surface" id="weatherDescription">Loading...</div>
                </div>
                <span class="material-symbols-rounded weather-icon" id="weatherIcon">
                    sunny
                </span>
            </div>
            <div class="weather-grid" id="weatherGrid">
                <!-- Weather items will be populated dynamically -->
            </div>
        </div>

        <!-- Tab Contents -->
        <div class="tab-content active" id="currentTab">
            <div class="hourly-forecast" id="hourlyForecast">
                <!-- Hourly forecast items will be added here -->
            </div>
            <div class="modules-grid">
                <div class="module-card" id="uvModule">
                    <span class="material-symbols-rounded module-icon">light_mode</span>
                    <div class="module-title on-surface">UV Index</div>
                    <div class="module-value on-surface" id="uvIndexValue">--</div>
                    <div class="module-unit on-surface" id="uvDescription">Current level</div>
                </div>
                <div class="module-card" id="windModule">
                    <span class="material-symbols-rounded module-icon">air</span>
                    <div class="module-title on-surface">Wind Gust</div>
                    <div class="module-value on-surface" id="windGustValue">--</div>
                    <div class="module-unit on-surface">km/h</div>
                </div>
            </div>
        </div>

        <!-- Map Tab -->
        <div class="tab-content" id="mapTab">
            <div id="weatherMap"></div>
        </div>

        <!-- History Tab -->
        <div class="tab-content" id="historyTab">
            <div class="history-controls">
                <div class="date-picker-container">
                    <input type="date" class="date-input" id="historyDate" max="">
                    <button class="history-button" onclick="loadHistoricalWeather()">
                        <span class="material-symbols-rounded">calendar_month</span>
                        Load Historical Data
                    </button>
                </div>
                <div id="historicalData">
                    <div style="text-align: center; padding: 40px;">
                        <span class="material-symbols-rounded" style="font-size: 48px; color: var(--weather-primary); margin-bottom: 16px;">history</span>
                        <div class="body-medium on-surface">Select a date to view historical weather data</div>
                        <div class="body-small on-surface" style="margin-top: 8px; opacity: 0.7;">Data available for the past 1 year</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Switch Pill -->
    <div class="bottom-switch">
        <button class="switch-option active" data-view="current">Current</button>
        <button class="switch-option" data-view="map">Maps</button>
        <button class="switch-option" data-view="history">History</button>
    </div>

    <script type="module">
        // ==================== WIGGLY RING LOADING ANIMATION ====================
        (function() {
            const canvas = document.getElementById('wigglyCanvas');
            const ctx = canvas.getContext('2d');
            
            const color = '#FFFFFF';
            const lineWidth = 4;
            const speed = 0.02;
            const amplitude = 2.5;
            const frequency = 10;
            
            let time = 0;
            let animationId = null;

            function resize() {
                const parent = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                
                const cmInPixels = 37.8;
                const size = 2 * cmInPixels;
                
                canvas.width = size * dpr;
                canvas.height = size * dpr;
                
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                
                ctx.scale(dpr, dpr);
            }

            function draw() {
                const width = 2 * 37.8;
                const height = 2 * 37.8;
                const centerX = width / 2;
                const centerY = height / 2;
                
                const baseRadius = (width / 2) - lineWidth - amplitude;
                
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.02) {
                    const primaryWave = Math.cos(angle * frequency + time) * amplitude;
                    const secondaryWave = Math.sin(angle * 5 - time * 1.5) * (amplitude * 0.4);
                    const tertiaryWave = Math.cos(angle * 8 + time * 0.7) * (amplitude * 0.2);
                    
                    const offset = primaryWave + secondaryWave + tertiaryWave;
                    const radius = baseRadius + offset;
                    
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                time += speed;
                
                if (canvas.offsetParent !== null) {
                    animationId = requestAnimationFrame(draw);
                }
            }

            function startAnimation() {
                if (!animationId) {
                    resize();
                    draw();
                }
            }

            function stopAnimation() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }

            window.addEventListener('load', () => {
                startAnimation();
            });

            window.addEventListener('resize', resize);
            
            window.wigglyRing = {
                start: startAnimation,
                stop: stopAnimation
            };
        })();

        // ==================== TELEGRAM SDK INTEGRATION ====================
        const { locationManager, init } = window.TelegramSDK;
        
        // DOM Elements
        const elements = {
            loadingScreen: document.getElementById('loadingScreen'),
            loadingText: document.getElementById('loadingText'),
            appContainer: document.getElementById('appContainer'),
            weatherElements: document.getElementById('weatherElements'),
            searchPill: document.getElementById('searchPill'),
            searchInput: document.getElementById('searchInput'),
            searchIcon: document.getElementById('searchIcon'),
            searchButton: document.getElementById('searchButton'),
            locationName: document.getElementById('locationName'),
            elevation: document.getElementById('elevation'),
            timezone: document.getElementById('timezone'),
            currentTemp: document.getElementById('currentTemp'),
            weatherDescription: document.getElementById('weatherDescription'),
            weatherIcon: document.getElementById('weatherIcon'),
            weatherGrid: document.getElementById('weatherGrid'),
            hourlyForecast: document.getElementById('hourlyForecast'),
            uvIndexValue: document.getElementById('uvIndexValue'),
            uvDescription: document.getElementById('uvDescription'),
            windGustValue: document.getElementById('windGustValue'),
            historyDate: document.getElementById('historyDate'),
            historicalData: document.getElementById('historicalData'),
            currentTab: document.getElementById('currentTab'),
            historyTab: document.getElementById('historyTab'),
            mapTab: document.getElementById('mapTab'),
            weatherMap: document.getElementById('weatherMap')
        };

        // Global variables
        let userLocation = null;
        let currentWeatherData = null;
        let leafletMap = null;
        let markersLayer = null;
        let weatherAnimationInterval = null;
        let activeWeatherAnimations = [];
        let mapUpdateTimeout = null;
        let searchTimeout = null;
        let searchCollapseTimeout = null;
        let webApp = null;

        // ==================== TELEGRAM WEB APP INTEGRATION ====================
        function initTelegramWebApp() {
            if (window.Telegram && window.Telegram.WebApp) {
                webApp = window.Telegram.WebApp;
                webApp.expand();
                webApp.ready();
                
                // Set Telegram header color to match weather theme
                updateTelegramHeaderColor();
                
                // Listen for theme changes
                webApp.onEvent('themeChanged', updateTelegramHeaderColor);
                webApp.onEvent('viewportChanged', updateTelegramHeaderColor);
            }
        }

        function updateTelegramHeaderColor() {
            if (!webApp) return;
            
            // Get computed style to get current weather primary color
            const computedStyle = getComputedStyle(document.documentElement);
            const weatherPrimary = computedStyle.getPropertyValue('--weather-primary').trim();
            
            // Convert hex color to RGB for Telegram
            let color;
            if (weatherPrimary.startsWith('#')) {
                const hex = weatherPrimary.substring(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                color = `rgb(${r}, ${g}, ${b})`;
            } else if (weatherPrimary.startsWith('rgb')) {
                color = weatherPrimary;
            } else {
                color = '#6750A4'; // Default
            }
            
            // Set header and background colors
            webApp.setHeaderColor(color);
            webApp.setBackgroundColor(color);
            
            // Set secondary color if available
            const weatherSecondary = computedStyle.getPropertyValue('--weather-secondary').trim();
            if (weatherSecondary && weatherSecondary !== weatherPrimary) {
                try {
                    webApp.setSecondaryBackgroundColor(weatherSecondary);
                } catch (e) {
                    console.log('Secondary color not supported in this version');
                }
            }
        }

        // ==================== RETRACTABLE SEARCH BAR ====================
        function initSearchBar() {
            let isExpanded = false;
            let lastInteractionTime = Date.now();
            
            // Toggle search bar on icon click
            elements.searchIcon.addEventListener('click', () => {
                expandSearchBar();
            });
            
            // Handle search button click
            elements.searchButton.addEventListener('click', handleSearch);
            
            // Handle Enter key in search input
            elements.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSearch();
                }
            });
            
            // Reset timer on user interaction
            elements.searchInput.addEventListener('input', resetSearchTimer);
            elements.searchInput.addEventListener('focus', resetSearchTimer);
            elements.searchButton.addEventListener('click', resetSearchTimer);
            elements.searchIcon.addEventListener('click', resetSearchTimer);
            
            function expandSearchBar() {
                elements.searchPill.classList.add('expanded');
                elements.searchInput.focus();
                isExpanded = true;
                resetSearchTimer();
            }
            
            function collapseSearchBar() {
                elements.searchPill.classList.remove('expanded');
                elements.searchInput.value = '';
                elements.searchInput.blur();
                isExpanded = false;
            }
            
            function resetSearchTimer() {
                lastInteractionTime = Date.now();
                clearTimeout(searchCollapseTimeout);
                searchCollapseTimeout = setTimeout(() => {
                    if (isExpanded && Date.now() - lastInteractionTime >= 15000) {
                        collapseSearchBar();
                    }
                }, 15000);
            }
            
            // Auto-collapse after 15 seconds
            resetSearchTimer();
            
            // Also collapse when clicking outside
            document.addEventListener('click', (e) => {
                if (isExpanded && 
                    !elements.searchPill.contains(e.target) && 
                    !elements.searchButton.contains(e.target)) {
                    collapseSearchBar();
                }
            });
        }

        // Initialize the app
        async function initApp() {
            try {
                updateLoadingText('Initializing...');
                
                // Initialize Telegram Web App
                initTelegramWebApp();
                
                // Initialize Telegram SDK
                init();
                
                // Initialize search bar
                initSearchBar();
                
                // Set up switch functionality
                setupSwitch();
                
                // Set up date picker for history
                setupHistoryDatePicker();
                
                // Get user location using Telegram SDK
                await getUserLocation();
                
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Failed to initialize app. Please try again.');
            }
        }

        // ==================== HISTORY DATE PICKER SETUP ====================
        function setupHistoryDatePicker() {
            const today = new Date();
            const oneYearAgo = new Date();
            oneYearAgo.setFullYear(today.getFullYear() - 1);
            
            // Set max to yesterday
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            elements.historyDate.max = yesterday.toISOString().split('T')[0];
            
            // Set default to 7 days ago
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            elements.historyDate.value = sevenDaysAgo.toISOString().split('T')[0];
        }

        // ==================== TELEGRAM SDK LOCATION ====================
        async function getUserLocation() {
            updateLoadingText('Detecting your location...');
            
            try {
                await locationManager.mount();
                
                if (!locationManager.isSupported()) {
                    console.log("Location tracking not supported, falling back to IP geolocation");
                    await getLocationByIP();
                    return;
                }
                
                const location = await locationManager.requestLocation();
                
                userLocation = {
                    latitude: location.latitude,
                    longitude: location.longitude,
                    accuracy: location.horizontal_accuracy
                };
                
                await reverseGeocode(location.latitude, location.longitude);
                await loadAllWeatherData();
                
            } catch (error) {
                console.error('Telegram location error:', error);
                updateLoadingText('Falling back to approximate location...');
                await getLocationByIP();
            }
        }

        async function getLocationByIP() {
            try {
                updateLoadingText('Getting approximate location...');
                const response = await fetch('https://ipapi.co/json/');
                if (!response.ok) throw new Error('IP location failed');
                
                const data = await response.json();
                userLocation = {
                    latitude: data.latitude,
                    longitude: data.longitude,
                    accuracy: 10000
                };
                
                elements.locationName.textContent = `${data.city}, ${data.country_name}`;
                elements.elevation.textContent = `${Math.round(data.latitude * 100)} m`;
                elements.timezone.textContent = data.timezone.split('/')[1] || data.timezone;
                
                await loadAllWeatherData();
                
            } catch (error) {
                console.error('IP location error:', error);
                userLocation = { latitude: 51.5074, longitude: -0.1278, accuracy: 50000 };
                elements.locationName.textContent = 'London, UK';
                elements.elevation.textContent = '35 m';
                elements.timezone.textContent = 'London';
                
                await loadAllWeatherData();
            }
        }

        async function reverseGeocode(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                const data = await response.json();
                
                if (data.address) {
                    const city = data.address.city || data.address.town || data.address.village || data.address.county;
                    const country = data.address.country;
                    if (city && country) {
                        elements.locationName.textContent = `${city}, ${country}`;
                    } else if (city) {
                        elements.locationName.textContent = city;
                    } else if (country) {
                        elements.locationName.textContent = country;
                    }
                }
                
                const elevationResponse = await fetch(`https://api.open-meteo.com/v1/elevation?latitude=${lat}&longitude=${lon}`);
                const elevationData = await elevationResponse.json();
                if (elevationData.elevation) {
                    elements.elevation.textContent = `${Math.round(elevationData.elevation[0])} m`;
                }
                
            } catch (error) {
                console.error('Reverse geocoding error:', error);
            }
        }

        // ==================== CONTINUOUS WEATHER ELEMENTS ANIMATION ====================
        function createWeatherElements(weatherCode, isDay, cloudCover = 50) {
            clearWeatherElements();
            if (weatherAnimationInterval) {
                clearInterval(weatherAnimationInterval);
            }
            
            activeWeatherAnimations.forEach(raf => cancelAnimationFrame(raf));
            activeWeatherAnimations = [];
            
            elements.weatherElements.innerHTML = '';
            
            createSunMoon(isDay);
            
            if (weatherCode >= 1 && weatherCode <= 3) {
                createClouds(Math.min(2, Math.floor(cloudCover / 30)));
                weatherAnimationInterval = setInterval(() => {
                    const currentClouds = document.querySelectorAll('.cloud').length;
                    if (currentClouds < 5) {
                        createClouds(1);
                    }
                }, 4000);
            }
            
            if (weatherCode >= 51 && weatherCode <= 65) {
                createRain(5);
                weatherAnimationInterval = setInterval(() => {
                    const currentRain = document.querySelectorAll('.rain-drop').length;
                    if (currentRain < 20) {
                        createRain(2);
                    }
                }, 300);
            }
            
            if (weatherCode >= 71 && weatherCode <= 77) {
                createSnow(3);
                weatherAnimationInterval = setInterval(() => {
                    const currentSnow = document.querySelectorAll('.snow-flake').length;
                    if (currentSnow < 12) {
                        createSnow(1);
                    }
                }, 800);
            }
            
            if (!isDay && (weatherCode === 0 || weatherCode === 1)) {
                createStars(10);
                weatherAnimationInterval = setInterval(() => {
                    const currentStars = document.querySelectorAll('.star').length;
                    if (currentStars < 18) {
                        createStars(1);
                    }
                }, 2000);
            }
            
            if (weatherCode >= 95 && weatherCode <= 99) {
                createLightning();
                weatherAnimationInterval = setInterval(() => {
                    createLightning();
                }, 5000);
            }
        }

        function createSunMoon(isDay) {
            const sunMoonContainer = document.createElement('div');
            
            if (isDay) {
                sunMoonContainer.innerHTML = `
                    <div class="sun" style="left: 20%; top: 20%;">
                        <div class="sun-rays">
                            ${Array.from({length: 12}, (_, i) => 
                                `<div class="sun-ray" style="transform: rotate(${i * 30}deg) translateY(-35px);"></div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            } else {
                const moon = document.createElement('div');
                moon.className = 'moon';
                moon.style.left = '80%';
                moon.style.top = '20%';
                sunMoonContainer.appendChild(moon);
            }
            
            elements.weatherElements.appendChild(sunMoonContainer);
        }

        function createClouds(count = 1) {
            for (let i = 0; i < count; i++) {
                const cloud = document.createElement('div');
                cloud.className = 'cloud';
                
                const size = 50 + Math.random() * 60;
                const top = 10 + Math.random() * 40;
                const left = -size - Math.random() * 50;
                const opacity = 0.4 + (Math.random() * 0.3);
                const speed = 25 + Math.random() * 15;
                
                cloud.style.width = `${size}px`;
                cloud.style.height = `${size * 0.5}px`;
                cloud.style.top = `${top}%`;
                cloud.style.left = `${left}px`;
                cloud.style.opacity = opacity;
                
                cloud.innerHTML = `
                    <div style="position: absolute; width: 60%; height: 60%; top: -30%; left: 10%; background: inherit; border-radius: 50%;"></div>
                    <div style="position: absolute; width: 40%; height: 40%; top: -20%; right: 10%; background: inherit; border-radius: 50%;"></div>
                `;
                
                elements.weatherElements.appendChild(cloud);
                
                let startTime = null;
                function animateCloud(time) {
                    if (!startTime) startTime = time;
                    const elapsed = (time - startTime) / 1000;
                    const progress = elapsed / speed;
                    
                    if (progress <= 1) {
                        const x = left + (window.innerWidth + size + 50) * progress;
                        cloud.style.transform = `translateX(${x}px)`;
                        const raf = requestAnimationFrame(animateCloud);
                        activeWeatherAnimations.push(raf);
                    } else {
                        cloud.remove();
                    }
                }
                
                const raf = requestAnimationFrame(animateCloud);
                activeWeatherAnimations.push(raf);
            }
        }

        function createRain(count = 2) {
            for (let i = 0; i < count; i++) {
                const drop = document.createElement('div');
                drop.className = 'rain-drop';
                
                const left = Math.random() * 100;
                const duration = 1 + Math.random() * 0.5;
                const delay = Math.random() * 0.3;
                const size = 1.5 + Math.random() * 1.5;
                
                drop.style.left = `${left}%`;
                drop.style.top = '-30px';
                drop.style.width = `${size}px`;
                drop.style.height = `${25 + Math.random() * 15}px`;
                
                elements.weatherElements.appendChild(drop);
                
                let startTime = null;
                function animateRain(time) {
                    if (!startTime) startTime = time;
                    const elapsed = (time - startTime) / 1000;
                    
                    if (elapsed < delay) {
                        const raf = requestAnimationFrame(animateRain);
                        activeWeatherAnimations.push(raf);
                        return;
                    }
                    
                    const progress = (elapsed - delay) / duration;
                    if (progress <= 1) {
                        const y = -30 + (window.innerHeight + 60) * progress;
                        const x = left + Math.sin(progress * Math.PI * 2.5) * 10;
                        drop.style.transform = `translate(${x}px, ${y}px)`;
                        drop.style.opacity = 1 - progress * 0.7;
                        const raf = requestAnimationFrame(animateRain);
                        activeWeatherAnimations.push(raf);
                    } else {
                        drop.remove();
                    }
                }
                
                const raf = requestAnimationFrame(animateRain);
                activeWeatherAnimations.push(raf);
            }
        }

        function createSnow(count = 1) {
            for (let i = 0; i < count; i++) {
                const flake = document.createElement('div');
                flake.className = 'snow-flake';
                
                const left = Math.random() * 100;
                const duration = 5 + Math.random() * 2;
                const delay = Math.random() * 1.5;
                const size = 3 + Math.random() * 3;
                
                flake.style.left = `${left}%`;
                flake.style.top = '-10px';
                flake.style.width = `${size}px`;
                flake.style.height = `${size}px`;
                
                elements.weatherElements.appendChild(flake);
                
                let startTime = null;
                function animateSnow(time) {
                    if (!startTime) startTime = time;
                    const elapsed = (time - startTime) / 1000;
                    
                    if (elapsed < delay) {
                        const raf = requestAnimationFrame(animateSnow);
                        activeWeatherAnimations.push(raf);
                        return;
                    }
                    
                    const progress = (elapsed - delay) / duration;
                    if (progress <= 1) {
                        const y = -10 + (window.innerHeight + 20) * progress;
                        const x = left + Math.sin(progress * Math.PI * 1.5) * 30;
                        const rotation = progress * 360;
                        flake.style.transform = `translate(${x}px, ${y}px) rotate(${rotation}deg)`;
                        flake.style.opacity = 1 - progress * 0.4;
                        const raf = requestAnimationFrame(animateSnow);
                        activeWeatherAnimations.push(raf);
                    } else {
                        flake.remove();
                    }
                }
                
                const raf = requestAnimationFrame(animateSnow);
                activeWeatherAnimations.push(raf);
            }
        }

        function createStars(count = 3) {
            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                const left = Math.random() * 100;
                const top = Math.random() * 100;
                const delay = Math.random() * 3;
                const size = 2 + Math.random() * 2;
                
                star.style.left = `${left}%`;
                star.style.top = `${top}%`;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.animationDelay = `${delay}s`;
                
                elements.weatherElements.appendChild(star);
            }
        }

        function createLightning() {
            const lightning = document.createElement('div');
            lightning.className = 'lightning';
            
            const left = 30 + Math.random() * 40;
            const height = 80 + Math.random() * 40;
            
            lightning.style.left = `${left}%`;
            lightning.style.height = `${height}px`;
            lightning.style.top = '10%';
            
            elements.weatherElements.appendChild(lightning);
            
            let flashCount = 0;
            function flash() {
                if (flashCount < 3) {
                    lightning.style.opacity = '1';
                    setTimeout(() => {
                        lightning.style.opacity = '0';
                        setTimeout(() => flash(), 100);
                    }, 50);
                    flashCount++;
                } else {
                    setTimeout(() => lightning.remove(), 1000);
                }
            }
            
            flash();
        }

        function clearWeatherElements() {
            elements.weatherElements.innerHTML = '';
            if (weatherAnimationInterval) {
                clearInterval(weatherAnimationInterval);
                weatherAnimationInterval = null;
            }
            activeWeatherAnimations.forEach(raf => cancelAnimationFrame(raf));
            activeWeatherAnimations = [];
        }

        // ==================== ENHANCED MAP FUNCTIONALITY ====================
        async function initWeatherMap() {
            if (!leafletMap) {
                leafletMap = L.map('weatherMap').setView([userLocation.latitude, userLocation.longitude], 8);
                
                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(leafletMap);

                // Add temperature layer
                L.tileLayer('https://tile.openweathermap.org/map/temp_new/{z}/{x}/{y}.png?appid={apiKey}', {
                    maxZoom: 19,
                    opacity: 0.5,
                    apiKey: 'YOUR_OPENWEATHER_API_KEY' // You would need to add your own API key
                }).addTo(leafletMap);

                markersLayer = L.layerGroup().addTo(leafletMap);
                
                await addCurrentLocationMarker();
                await addNearbyCities();
                
                leafletMap.on('moveend', handleMapMoveEnd);
                leafletMap.on('zoomend', handleMapMoveEnd);
                
                // Add scale control
                L.control.scale({imperial: false}).addTo(leafletMap);
            }
            
            elements.mapTab.classList.add('map-fullscreen');
            document.body.classList.add('map-mode');
            
            const backButton = document.createElement('div');
            backButton.className = 'map-back-button';
            backButton.innerHTML = '<span class="material-symbols-rounded">arrow_back</span>';
            backButton.onclick = exitFullscreenMap;
            document.body.appendChild(backButton);
            
            setTimeout(() => {
                leafletMap.invalidateSize();
                leafletMap.setView([userLocation.latitude, userLocation.longitude], leafletMap.getZoom());
            }, 100);
        }

        async function addCurrentLocationMarker() {
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&current_weather=true`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.current_weather) {
                    const code = data.current_weather.weathercode;
                    const isDay = data.current_weather.is_day === 1;
                    const iconName = getWeatherIconName(code, isDay);
                    const temp = Math.round(data.current_weather.temperature);
                    const windSpeed = Math.round(data.current_weather.windspeed);
                    const description = getWeatherDescription(code);

                    const customIcon = L.divIcon({
                        html: `
                            <div class="weather-marker current">
                                <span class="material-symbols-rounded" style="font-size: 24px; color: white;">${iconName}</span>
                                <div class="marker-temp">${temp}°</div>
                            </div>
                        `,
                        className: '',
                        iconSize: [70, 70],
                        iconAnchor: [35, 35]
                    });

                    const marker = L.marker([userLocation.latitude, userLocation.longitude], { icon: customIcon }).addTo(markersLayer);
                    
                    const popupContent = `
                        <div style="font-family: 'Inter', sans-serif; min-width: 200px;">
                            <b style="color: #FF5722; font-size: 16px;">📍 Your Location</b><br>
                            <div style="display: flex; align-items: center; gap: 12px; margin: 12px 0;">
                                <span class="material-symbols-rounded" style="color: #FF5722; font-size: 24px;">${iconName}</span>
                                <span style="font-size: 28px; font-weight: 600; color: #FF5722;">${temp}°C</span>
                            </div>
                            <div style="font-size: 14px; color: #666; margin: 8px 0; padding: 8px; background: #f5f5f5; border-radius: 8px;">
                                ${description}
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; color: #888; margin-bottom: 4px;">Wind</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #333;">${windSpeed} km/h</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 11px; color: #888; margin-bottom: 4px;">Feels Like</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #333;">${temp}°</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                }
            } catch (error) {
                console.error('Failed to add current location marker:', error);
            }
        }

        async function addNearbyCities() {
            const nearbyCities = [
                { lat: userLocation.latitude + 0.5, lon: userLocation.longitude + 0.5, name: "North East" },
                { lat: userLocation.latitude + 0.5, lon: userLocation.longitude - 0.5, name: "North West" },
                { lat: userLocation.latitude - 0.5, lon: userLocation.longitude + 0.5, name: "South East" },
                { lat: userLocation.latitude - 0.5, lon: userLocation.longitude - 0.5, name: "South West" },
                { lat: userLocation.latitude, lon: userLocation.longitude + 0.7, name: "East" },
                { lat: userLocation.latitude, lon: userLocation.longitude - 0.7, name: "West" },
                { lat: userLocation.latitude + 0.7, lon: userLocation.longitude, name: "North" },
                { lat: userLocation.latitude - 0.7, lon: userLocation.longitude, name: "South" }
            ];

            for (const [index, city] of nearbyCities.entries()) {
                await new Promise(resolve => setTimeout(resolve, index * 150));
                await addCityMarker(city.lat, city.lon, city.name);
            }
        }

        async function addCityMarker(lat, lon, name) {
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.current_weather) {
                    const code = data.current_weather.weathercode;
                    const isDay = data.current_weather.is_day === 1;
                    const iconName = getWeatherIconName(code, isDay);
                    const temp = Math.round(data.current_weather.temperature);
                    const windSpeed = Math.round(data.current_weather.windspeed);
                    const description = getWeatherDescription(code);

                    const customIcon = L.divIcon({
                        html: `
                            <div class="weather-marker">
                                <span class="material-symbols-rounded" style="font-size: 24px; color: var(--weather-primary);">${iconName}</span>
                                <div class="marker-temp">${temp}°</div>
                            </div>
                        `,
                        className: '',
                        iconSize: [70, 70],
                        iconAnchor: [35, 35]
                    });

                    const marker = L.marker([lat, lon], { icon: customIcon }).addTo(markersLayer);
                    
                    const popupContent = `
                        <div style="font-family: 'Inter', sans-serif; min-width: 180px;">
                            <b style="color: var(--weather-primary); font-size: 15px;">📍 ${name}</b><br>
                            <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                                <span class="material-symbols-rounded" style="color: var(--weather-primary); font-size: 22px;">${iconName}</span>
                                <span style="font-size: 26px; font-weight: 600; color: var(--weather-primary);">${temp}°C</span>
                            </div>
                            <div style="font-size: 13px; color: #666; margin: 6px 0;">${description}</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 10px; color: #888; margin-bottom: 2px;">Wind</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #333;">${windSpeed} km/h</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 10px; color: #888; margin-bottom: 2px;">Feels</div>
                                    <div style="font-size: 14px; font-weight: 600; color: #333;">${temp}°</div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    
                    marker.on('click', () => {
                        userLocation = { latitude: lat, longitude: lon };
                        loadAllWeatherData();
                        exitFullscreenMap();
                        document.querySelector('.switch-option[data-view="current"]').click();
                    });
                }
            } catch (error) {
                console.error('Failed to add city marker:', error);
            }
        }

        async function handleMapMoveEnd() {
            if (mapUpdateTimeout) {
                clearTimeout(mapUpdateTimeout);
            }
            
            mapUpdateTimeout = setTimeout(async () => {
                markersLayer.clearLayers();
                await addCurrentLocationMarker();
                
                const bounds = leafletMap.getBounds();
                const center = leafletMap.getCenter();
                const zoom = leafletMap.getZoom();
                
                // Add cities in current view
                await addCitiesInView(bounds, center, zoom);
            }, 500);
        }

        async function addCitiesInView(bounds, center, zoom) {
            let cityCount;
            if (zoom < 6) cityCount = 12;
            else if (zoom < 8) cityCount = 8;
            else cityCount = 4;
            
            const latDiff = bounds.getNorth() - bounds.getSouth();
            const lngDiff = bounds.getEast() - bounds.getWest();
            const gridSize = Math.ceil(Math.sqrt(cityCount));
            const latStep = latDiff / (gridSize + 1);
            const lngStep = lngDiff / (gridSize + 1);
            
            const cities = [];
            
            for (let i = 1; i <= gridSize; i++) {
                for (let j = 1; j <= gridSize; j++) {
                    if (cities.length >= cityCount) break;
                    
                    const lat = bounds.getSouth() + (latStep * i);
                    const lng = bounds.getWest() + (lngStep * j);
                    
                    if (bounds.contains([lat, lng])) {
                        const distance = Math.sqrt(
                            Math.pow(lat - userLocation.latitude, 2) + 
                            Math.pow(lng - userLocation.longitude, 2)
                        );
                        
                        if (distance > 0.1) {
                            cities.push({
                                lat: lat,
                                lon: lng,
                                name: `City ${cities.length + 1}`
                            });
                        }
                    }
                }
            }
            
            for (const [index, city] of cities.entries()) {
                await new Promise(resolve => setTimeout(resolve, index * 100));
                await addCityMarker(city.lat, city.lon, city.name);
            }
        }

        function exitFullscreenMap() {
            elements.mapTab.classList.remove('map-fullscreen');
            document.body.classList.remove('map-mode');
            
            const backButton = document.querySelector('.map-back-button');
            if (backButton) {
                backButton.remove();
            }
            
            if (leafletMap && userLocation) {
                leafletMap.setView([userLocation.latitude, userLocation.longitude], 8);
            }
            
            if (leafletMap) {
                setTimeout(() => {
                    leafletMap.invalidateSize();
                }, 100);
            }
        }

        // ==================== IMPROVED HISTORICAL WEATHER ====================
        async function loadHistoricalWeather() {
            const selectedDate = elements.historyDate.value;
            if (!selectedDate) {
                showHistoryError('Please select a date');
                return;
            }
            
            // Show loading state
            elements.historicalData.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div class="loading-spinner" style="width: 40px; height: 40px; border: 3px solid var(--weather-primary); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                    <style>@keyframes spin { to { transform: rotate(360deg); } }</style>
                    <div class="body-medium on-surface">Loading historical data...</div>
                </div>
            `;
            
            try {
                // Calculate date range for the selected date
                const startDate = selectedDate;
                const endDate = selectedDate;
                
                const historicalUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&start_date=${startDate}&end_date=${endDate}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weathercode,windspeed_10m_max&timezone=auto`;
                
                const response = await fetch(historicalUrl);
                if (!response.ok) throw new Error('Historical API error');
                
                const data = await response.json();
                
                if (data.daily && data.daily.time.length > 0) {
                    const date = new Date(selectedDate);
                    const formattedDate = date.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    
                    const maxTemp = Math.round(data.daily.temperature_2m_max[0]);
                    const minTemp = Math.round(data.daily.temperature_2m_min[0]);
                    const precip = data.daily.precipitation_sum[0].toFixed(1);
                    const windSpeed = Math.round(data.daily.windspeed_10m_max[0]);
                    const weatherCode = data.daily.weathercode[0];
                    const weatherDescription = getWeatherDescription(weatherCode);
                    const weatherIcon = getWeatherIconName(weatherCode, true);
                    
                    elements.historicalData.innerHTML = `
                        <div class="historical-card">
                            <div class="historical-date">${formattedDate}</div>
                            <div class="historical-stats">
                                <div class="historical-stat">
                                    <div class="historical-stat-label">High</div>
                                    <div class="historical-stat-value">${maxTemp}°</div>
                                    <div class="historical-stat-unit">Max Temperature</div>
                                </div>
                                <div class="historical-stat">
                                    <div class="historical-stat-label">Low</div>
                                    <div class="historical-stat-value">${minTemp}°</div>
                                    <div class="historical-stat-unit">Min Temperature</div>
                                </div>
                                <div class="historical-stat">
                                    <div class="historical-stat-label">Precip</div>
                                    <div class="historical-stat-value">${precip}</div>
                                    <div class="historical-stat-unit">mm</div>
                                </div>
                            </div>
                            <div style="background: rgba(103, 80, 164, 0.08); border-radius: var(--shape-medium); padding: 16px; margin-top: 20px;">
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                    <span class="material-symbols-rounded" style="color: var(--weather-primary); font-size: 24px;">${weatherIcon}</span>
                                    <div style="flex: 1;">
                                        <div style="font-size: 16px; font-weight: 500; color: var(--weather-on-surface);">${weatherDescription}</div>
                                        <div style="font-size: 14px; color: var(--weather-on-surface); opacity: 0.7;">Weather Conditions</div>
                                    </div>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div style="text-align: center; padding: 12px; background: white; border-radius: var(--shape-medium);">
                                        <div style="font-size: 12px; color: var(--weather-on-surface); opacity: 0.7; margin-bottom: 4px;">Wind Speed</div>
                                        <div style="font-size: 18px; font-weight: 600; color: var(--weather-primary);">${windSpeed} km/h</div>
                                    </div>
                                    <div style="text-align: center; padding: 12px; background: white; border-radius: var(--shape-medium);">
                                        <div style="font-size: 12px; color: var(--weather-on-surface); opacity: 0.7; margin-bottom: 4px;">Temp Range</div>
                                        <div style="font-size: 18px; font-weight: 600; color: var(--weather-primary);">${minTemp}° - ${maxTemp}°</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    showHistoryError('No historical data available for this date');
                }
                
            } catch (error) {
                console.error('Historical data error:', error);
                showHistoryError('Failed to load historical data. Please try another date.');
            }
        }

        function showHistoryError(message) {
            elements.historicalData.innerHTML = `
                <div class="error-state">
                    <span class="material-symbols-rounded error-icon">error</span>
                    <div class="error-title on-surface">Data Unavailable</div>
                    <div class="error-message on-surface">${message}</div>
                    <button class="retry-button" onclick="loadHistoricalWeather()" style="margin-top: 16px;">Try Again</button>
                </div>
            `;
        }

        // ==================== WEATHER DATA FETCHING ====================
        async function loadAllWeatherData() {
            try {
                updateLoadingText('Loading weather data...');
                
                await Promise.all([
                    loadCurrentWeather(),
                    loadHourlyForecast()
                ]);
                
                // Update Telegram header color with new weather theme
                updateTelegramHeaderColor();
                
                // Hide loading screen with animation
                setTimeout(() => {
                    elements.loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        elements.loadingScreen.style.display = 'none';
                        elements.appContainer.style.display = 'flex';
                        setTimeout(() => {
                            elements.appContainer.style.opacity = '1';
                        }, 50);
                    }, 300);
                }, 500);
                
            } catch (error) {
                console.error('Weather data loading error:', error);
                showError('Failed to load weather data. Please check your connection.');
            }
        }

        async function loadCurrentWeather() {
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&current_weather=true&hourly=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,rain,visibility,wind_speed_10m,wind_gusts_10m,cloud_cover,uv_index&daily=sunrise,sunset,uv_index_max&timezone=auto&forecast_days=2`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Weather API error');
                
                const data = await response.json();
                currentWeatherData = data;
                
                updateCurrentWeatherUI(data);
                updateWeatherBackground(data.current_weather.weathercode, data.current_weather.is_day);
                createWeatherElements(data.current_weather.weathercode, data.current_weather.is_day, data.hourly.cloud_cover[new Date().getHours()] || 50);
                
            } catch (error) {
                console.error('Current weather error:', error);
                throw error;
            }
        }

        async function loadHourlyForecast() {
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&hourly=temperature_2m,weathercode&timezone=auto&forecast_days=2`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                updateHourlyForecastUI(data);
                
            } catch (error) {
                console.error('Hourly forecast error:', error);
            }
        }

        // ==================== UI UPDATES ====================
        function updateCurrentWeatherUI(data) {
            const current = data.current_weather;
            const hourly = data.hourly;
            const currentIndex = new Date().getHours();
            
            elements.currentTemp.textContent = Math.round(current.temperature);
            elements.weatherDescription.textContent = getWeatherDescription(current.weathercode);
            
            updateWeatherIcon(current.weathercode, current.is_day);
            updateWeatherGrid(data, currentIndex);
            
            const uvIndex = Math.round(hourly.uv_index[currentIndex]);
            elements.uvIndexValue.textContent = uvIndex;
            elements.uvDescription.textContent = getUVDescription(uvIndex);
            
            elements.windGustValue.textContent = Math.round(hourly.wind_gusts_10m[currentIndex]);
        }

        function updateWeatherGrid(data, currentIndex) {
            const hourly = data.hourly;
            
            const gridItems = [
                {
                    icon: 'thermostat',
                    label: 'Feels like',
                    value: Math.round(hourly.apparent_temperature[currentIndex]) + '°',
                    unit: 'Real feel'
                },
                {
                    icon: 'humidity_percentage',
                    label: 'Humidity',
                    value: Math.round(hourly.relative_humidity_2m[currentIndex]) + '%',
                    unit: 'Relative'
                },
                {
                    icon: 'air',
                    label: 'Wind',
                    value: Math.round(hourly.wind_speed_10m[currentIndex]),
                    unit: 'km/h'
                },
                {
                    icon: 'rainy',
                    label: 'Precipitation',
                    value: hourly.precipitation[currentIndex].toFixed(1),
                    unit: 'mm'
                },
                {
                    icon: 'visibility',
                    label: 'Visibility',
                    value: (hourly.visibility[currentIndex] / 1000).toFixed(1),
                    unit: 'km'
                },
                {
                    icon: 'cloud',
                    label: 'Cloud cover',
                    value: Math.round(hourly.cloud_cover[currentIndex]) + '%',
                    unit: 'Sky coverage'
                }
            ];
            
            elements.weatherGrid.innerHTML = gridItems.map(item => `
                <div class="weather-item">
                    <span class="material-symbols-rounded weather-icon-small">${item.icon}</span>
                    <div class="weather-label on-surface">${item.label}</div>
                    <div class="weather-value on-surface">${item.value}</div>
                    <div class="weather-unit on-surface">${item.unit}</div>
                </div>
            `).join('');
        }

        function updateHourlyForecastUI(data) {
            const hourly = data.hourly;
            const currentHour = new Date().getHours();
            
            elements.hourlyForecast.innerHTML = '';
            
            for (let i = 0; i < 8; i++) {
                const hourIndex = currentHour + i;
                if (hourIndex >= hourly.time.length) break;
                
                const hourTime = new Date(hourly.time[hourIndex]);
                const hourStr = hourTime.getHours().toString().padStart(2, '0') + ':00';
                const temp = Math.round(hourly.temperature_2m[hourIndex]);
                const weatherCode = hourly.weathercode[hourIndex];
                
                const hourItem = document.createElement('div');
                hourItem.className = 'hour-item';
                hourItem.innerHTML = `
                    <div class="hour-time on-surface">${hourStr}</div>
                    <span class="material-symbols-rounded" style="font-size: 24px; color: var(--weather-primary); margin: 8px 0;">
                        ${getWeatherIconName(weatherCode, hourTime.getHours() >= 6 && hourTime.getHours() < 18)}
                    </span>
                    <div class="hour-temp on-surface">${temp}°</div>
                `;
                
                elements.hourlyForecast.appendChild(hourItem);
            }
        }

        function updateWeatherBackground(weatherCode, isDay) {
            document.body.className = '';
            
            if (!isDay) {
                if (weatherCode === 0) {
                    document.body.classList.add('clear-night');
                } else if (weatherCode === 1 || weatherCode === 2) {
                    document.body.classList.add('partly-cloudy-night');
                } else if (weatherCode === 3) {
                    document.body.classList.add('cloudy');
                } else if (weatherCode >= 51 && weatherCode <= 65) {
                    document.body.classList.add('rainy');
                } else if (weatherCode >= 71 && weatherCode <= 77) {
                    document.body.classList.add('snowy');
                } else if (weatherCode >= 95 && weatherCode <= 99) {
                    document.body.classList.add('thunderstorm');
                } else if (weatherCode === 45 || weatherCode === 48) {
                    document.body.classList.add('foggy');
                } else {
                    document.body.classList.add('clear-night');
                }
            } else {
                if (weatherCode === 0) {
                    document.body.classList.add('clear-day');
                } else if (weatherCode === 1 || weatherCode === 2) {
                    document.body.classList.add('partly-cloudy-day');
                } else if (weatherCode === 3) {
                    document.body.classList.add('cloudy');
                } else if (weatherCode >= 51 && weatherCode <= 65) {
                    document.body.classList.add('rainy');
                } else if (weatherCode >= 71 && weatherCode <= 77) {
                    document.body.classList.add('snowy');
                } else if (weatherCode >= 95 && weatherCode <= 99) {
                    document.body.classList.add('thunderstorm');
                } else if (weatherCode === 45 || weatherCode === 48) {
                    document.body.classList.add('foggy');
                } else {
                    document.body.classList.add('clear-day');
                }
            }
            
            // Update Telegram header color when weather changes
            updateTelegramHeaderColor();
        }

        function updateWeatherIcon(weatherCode, isDay) {
            elements.weatherIcon.textContent = getWeatherIconName(weatherCode, isDay);
        }

        function getWeatherIconName(weatherCode, isDay) {
            if (!isDay) {
                if (weatherCode === 0) return 'clear_night';
                if (weatherCode >= 1 && weatherCode <= 3) return 'partly_cloudy_night';
                return 'cloudy';
            }
            
            if (weatherCode === 0) return 'sunny';
            if (weatherCode === 1) return 'partly_cloudy_day';
            if (weatherCode === 2 || weatherCode === 3) return 'cloudy';
            if (weatherCode >= 51 && weatherCode <= 65) return 'rainy';
            if (weatherCode >= 71 && weatherCode <= 77) return 'weather_snowy';
            if (weatherCode >= 80 && weatherCode <= 82) return 'rainy';
            if (weatherCode >= 85 && weatherCode <= 86) return 'weather_snowy';
            if (weatherCode >= 95 && weatherCode <= 99) return 'thunderstorm';
            if (weatherCode === 45 || weatherCode === 48) return 'foggy';
            return 'sunny';
        }

        function getWeatherDescription(weatherCode) {
            const descriptions = {
                0: 'Clear sky',
                1: 'Mainly clear',
                2: 'Partly cloudy',
                3: 'Overcast',
                45: 'Foggy',
                48: 'Rime fog',
                51: 'Light drizzle',
                53: 'Moderate drizzle',
                55: 'Dense drizzle',
                61: 'Slight rain',
                63: 'Moderate rain',
                65: 'Heavy rain',
                71: 'Slight snow',
                73: 'Moderate snow',
                75: 'Heavy snow',
                80: 'Slight showers',
                81: 'Moderate showers',
                82: 'Violent showers',
                85: 'Slight snow showers',
                86: 'Heavy snow showers',
                95: 'Thunderstorm',
                96: 'Thunderstorm with hail',
                99: 'Heavy thunderstorm with hail'
            };
            return descriptions[weatherCode] || 'Unknown';
        }

        function getUVDescription(uvIndex) {
            if (uvIndex <= 2) return 'Low';
            if (uvIndex <= 5) return 'Moderate';
            if (uvIndex <= 7) return 'High';
            if (uvIndex <= 10) return 'Very High';
            return 'Extreme';
        }

        // ==================== UTILITY FUNCTIONS ====================
        function setupSwitch() {
            const switchOptions = document.querySelectorAll('.switch-option');
            const tabs = {
                current: document.getElementById('currentTab'),
                map: document.getElementById('mapTab'),
                history: document.getElementById('historyTab')
            };

            switchOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const view = option.dataset.view;
                    
                    if (document.body.classList.contains('map-mode') && view !== 'map') {
                        exitFullscreenMap();
                    }
                    
                    switchOptions.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    Object.values(tabs).forEach(t => t.classList.remove('active'));
                    tabs[view].classList.add('active');

                    if (view === 'map') {
                        setTimeout(() => {
                            initWeatherMap();
                        }, 100);
                    }
                });
            });
        }

        async function handleSearch() {
            const query = elements.searchInput.value.trim();
            if (!query) return;
            
            updateLoadingText('Searching location...');
            elements.loadingScreen.style.display = 'flex';
            elements.appContainer.style.display = 'none';
            
            try {
                const geocodeUrl = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=1`;
                const response = await fetch(geocodeUrl);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const location = data.results[0];
                    userLocation = {
                        latitude: location.latitude,
                        longitude: location.longitude
                    };
                    
                    elements.locationName.textContent = location.name;
                    elements.elevation.textContent = `${Math.round(location.elevation || 0)} m`;
                    elements.timezone.textContent = location.timezone.split('/')[1] || location.timezone;
                    
                    await loadAllWeatherData();
                    
                    if (leafletMap) {
                        leafletMap.setView([location.latitude, location.longitude], 8);
                        markersLayer.clearLayers();
                        await addCurrentLocationMarker();
                        await addNearbyCities();
                    }
                } else {
                    showError('Location not found');
                }
            } catch (error) {
                console.error('Search error:', error);
                showError('Search failed. Please try again.');
            }
        }

        function updateLoadingText(text) {
            if (elements.loadingText) {
                elements.loadingText.textContent = text;
            }
        }

        function showError(message) {
            elements.loadingScreen.innerHTML = `
                <div class="error-state">
                    <span class="material-symbols-rounded error-icon">error</span>
                    <div class="error-title" style="color: white;">Oops!</div>
                    <div class="error-message" style="color: white;">${message}</div>
                    <button class="retry-button" onclick="location.reload()" style="margin-top: 16px;">Try Again</button>
                </div>
            `;
        }

        // ==================== INITIALIZE APP ====================
        document.addEventListener('DOMContentLoaded', initApp);

        // Auto-refresh every 15 minutes
        setInterval(() => {
            if (userLocation) {
                loadCurrentWeather();
            }
        }, 15 * 60 * 1000);

    </script>
</body>
</html>