<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WeatherFlow</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,300..700,0..1,-25..200" rel="stylesheet" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            /* Dynamic weather colors */
            --weather-primary: #6750A4;
            --weather-secondary: #FFB2FF;
            --weather-gradient: linear-gradient(135deg, #6750A4 0%, #FFB2FF 100%);
            --weather-surface: rgba(255, 255, 255, 0.95);
            --weather-on-gradient: #FFFFFF;
            --weather-on-surface: #1C1B1F;
            
            /* Shapes */
            --shape-xl: 28px;
            --shape-l: 20px;
            --shape-m: 16px;
        }

        body {
            background: var(--weather-gradient);
            color: var(--weather-on-gradient);
            min-height: 100vh;
            transition: background 0.8s ease;
            overflow-x: hidden;
        }

        /* --- LOADING SCREEN --- */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #808080; /* Requested Grey Background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        /* The container for the 2cm canvas */
        .loader-container {
            width: 2cm;
            height: 2cm;
            position: relative;
            /* Flex to center the canvas if needed, though canvas fills it */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas#wigglyCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .loading-text {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            margin-top: 24px;
            letter-spacing: 0.5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* --- MAIN APP UI --- */
        .container {
            padding: 100px 20px 100px;
            max-width: 500px;
            margin: 0 auto;
            display: none; /* Hidden until loaded */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        /* Weather Elements (Background Effects) */
        .weather-elements {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        /* Search Bar */
        .search-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            z-index: 100;
            display: flex;
            gap: 12px;
        }

        .search-pill {
            flex: 1;
            background: var(--weather-surface);
            backdrop-filter: blur(20px);
            border-radius: 100px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .search-input {
            border: none;
            background: transparent;
            font-size: 16px;
            width: 100%;
            outline: none;
            color: var(--weather-on-surface);
        }

        .search-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--weather-primary);
            border: none;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: pointer;
        }

        /* Weather Card */
        .weather-card {
            background: var(--weather-surface);
            border-radius: var(--shape-xl);
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            z-index: 10;
        }

        .location-title {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .location-name { font-size: 28px; font-weight: 500; }
        .location-meta { font-size: 14px; opacity: 0.9; margin-top: 4px; }

        .temp-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .main-temp {
            font-size: 64px;
            font-weight: 300;
            line-height: 1;
            color: var(--weather-on-surface);
        }

        .weather-icon-lg {
            font-size: 64px;
            color: var(--weather-primary);
        }

        .desc-text {
            color: var(--weather-on-surface);
            font-size: 18px;
            margin-top: 8px;
            opacity: 0.8;
            text-transform: capitalize;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 24px;
        }

        .stat-item {
            background: rgba(103, 80, 164, 0.08);
            border-radius: var(--shape-m);
            padding: 12px;
            text-align: center;
        }

        .stat-label { font-size: 12px; opacity: 0.7; color: var(--weather-on-surface); text-transform: uppercase; }
        .stat-value { font-size: 16px; font-weight: 600; color: var(--weather-on-surface); margin-top: 4px; }

        /* Weather States */
        body.clear-day { --weather-gradient: linear-gradient(135deg, #FFB74D, #FF9800); --weather-primary: #FF9800; }
        body.clear-night { --weather-gradient: linear-gradient(135deg, #1A237E, #311B92); --weather-primary: #304FFE; }
        body.rainy { --weather-gradient: linear-gradient(135deg, #42A5F5, #1565C0); --weather-primary: #1565C0; }
        body.cloudy { --weather-gradient: linear-gradient(135deg, #90A4AE, #546E7A); --weather-primary: #546E7A; }

        /* Animation Elements (CSS Only placeholders) */
        .sun-moon {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            background: white; top: 10%; right: 10%;
            box-shadow: 0 0 40px rgba(255,255,255,0.5);
            transition: all 1s;
        }
    </style>
</head>
<body>

    <div class="loading-screen" id="loadingScreen">
        <div class="loader-container">
            <canvas id="wigglyCanvas"></canvas>
        </div>
        <div class="loading-text" id="loadingText">Detecting location...</div>
    </div>

    <div class="weather-elements" id="bgEffects"></div>

    <div class="search-container">
        <div class="search-pill">
            <span class="material-symbols-rounded" style="color:var(--weather-primary)">search</span>
            <input type="text" class="search-input" id="searchInput" placeholder="Search city...">
        </div>
        <button class="search-btn" id="searchBtn">
            <span class="material-symbols-rounded">arrow_forward</span>
        </button>
    </div>

    <div class="container" id="appContainer">
        <div class="location-title">
            <div class="location-name" id="locName">--</div>
            <div class="location-meta" id="locMeta">--</div>
        </div>

        <div class="weather-card">
            <div class="temp-display">
                <div>
                    <div class="main-temp"><span id="tempVal">--</span>°</div>
                    <div class="desc-text" id="weatherDesc">--</div>
                </div>
                <span class="material-symbols-rounded weather-icon-lg" id="weatherIcon">wb_sunny</span>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Humidity</div>
                    <div class="stat-value" id="humVal">--%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Wind</div>
                    <div class="stat-value" id="windVal">-- km/h</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Feels Like</div>
                    <div class="stat-value" id="feelVal">--°</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('wigglyCanvas');
        const ctx = canvas.getContext('2d');
        
        let animationFrameId;
        let time = 0;
        
        // Animation Config
        const CONFIG = {
            color: '#FFFFFF',
            lineWidth: 3,
            amplitude: 4,     // How much it wiggles (pixels)
            frequency: 4,     // How many waves
            speed: 0.08       // Rotation speed
        };

        function resizeCanvas() {
            // High DPI Display Support
            const parent = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const rect = parent.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Scale context to match
            ctx.scale(dpr, dpr);
            
            // Reset transforms for the draw loop logic
            return { width: rect.width, height: rect.height };
        }

        function animateLoader() {
            const { width, height } = resizeCanvas(); // Keep resizing to be safe
            const cx = width / 2;
            const cy = height / 2;
            const radius = (Math.min(width, height) / 2) - CONFIG.amplitude - CONFIG.lineWidth;

            ctx.clearRect(0, 0, width, height); // Clear based on CSS pixels (scaled)
            
            // Draw the Wiggle
            ctx.beginPath();
            for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
                // Determine offset based on sine waves
                // Wave 1: Main rotation
                let offset = Math.sin(angle * CONFIG.frequency + time) * CONFIG.amplitude;
                // Wave 2: Organic irregularity
                offset += Math.sin(angle * 3 - time * 1.5) * (CONFIG.amplitude * 0.5);

                const r = radius + offset;
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);

                if (angle === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // Style
            ctx.strokeStyle = CONFIG.color;
            ctx.lineWidth = CONFIG.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            time += CONFIG.speed;
            animationFrameId = requestAnimationFrame(animateLoader);
        }

        // Start Animation
        animateLoader();

        // Helper to stop animation when loaded
        function stopLoader() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            document.getElementById('loadingScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                const app = document.getElementById('appContainer');
                app.style.display = 'block';
                setTimeout(() => app.style.opacity = '1', 50);
            }, 500);
        }
    </script>

    <script type="module">
        import { locationManager, init } from 'https://unpkg.com/@telegram-apps/sdk?module';

        // Initialize Telegram SDK
        try { init(); } catch (e) { console.log('SDK Init:', e); }

        const elements = {
            locName: document.getElementById('locName'),
            locMeta: document.getElementById('locMeta'),
            tempVal: document.getElementById('tempVal'),
            weatherDesc: document.getElementById('weatherDesc'),
            weatherIcon: document.getElementById('weatherIcon'),
            humVal: document.getElementById('humVal'),
            windVal: document.getElementById('windVal'),
            feelVal: document.getElementById('feelVal'),
            searchInput: document.getElementById('searchInput'),
            bgEffects: document.getElementById('bgEffects')
        };

        // --- Core Functions ---

        async function startApp() {
            try {
                // 1. Try Telegram Location
                if (locationManager.isSupported()) {
                    await locationManager.mount();
                    const loc = await locationManager.requestLocation();
                    await fetchWeather(loc.latitude, loc.longitude);
                } else {
                    throw new Error("Not supported");
                }
            } catch (err) {
                console.log("Fallback to IP Geolocation", err);
                await fetchLocationByIP();
            }
        }

        async function fetchLocationByIP() {
            try {
                const res = await fetch('https://ipapi.co/json/');
                const data = await res.json();
                await fetchWeather(data.latitude, data.longitude, data.city);
            } catch (e) {
                // Absolute fallback (New York)
                await fetchWeather(40.71, -74.00, "New York (Default)");
            }
        }

        async function fetchWeather(lat, lon, cityNameOverride = null) {
            // Update Text
            document.getElementById('loadingText').innerText = "Analyzing weather...";

            try {
                // Open-Meteo API
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=relative_humidity_2m,apparent_temperature&daily=sunrise,sunset&timezone=auto`;
                const response = await fetch(url);
                const data = await response.json();

                // Reverse Geocode for name if not provided
                let displayCity = cityNameOverride;
                if (!displayCity) {
                    const geoRes = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                    const geoData = await geoRes.json();
                    displayCity = geoData.address.city || geoData.address.town || "Unknown Location";
                }

                updateUI(data, displayCity);
                stopLoader(); // Stops the wiggly canvas

            } catch (e) {
                console.error(e);
                alert("Failed to load weather data.");
                stopLoader();
            }
        }

        function updateUI(data, city) {
            const current = data.current_weather;
            const hourly = data.hourly;
            const hourIndex = new Date().getHours();

            // Text Updates
            elements.locName.textContent = city;
            elements.locMeta.textContent = `${data.timezone}`;
            elements.tempVal.textContent = Math.round(current.temperature);
            elements.windVal.textContent = `${current.windspeed} km/h`;
            elements.humVal.textContent = `${hourly.relative_humidity_2m[hourIndex]}%`;
            elements.feelVal.textContent = `${Math.round(hourly.apparent_temperature[hourIndex])}°`;
            
            // Weather Code Parsing
            const code = current.weathercode;
            const isDay = current.is_day === 1;
            
            let icon = 'wb_sunny';
            let desc = 'Clear Sky';
            let bgClass = isDay ? 'clear-day' : 'clear-night';

            // Simple WMO Code mapping
            if (code > 0 && code <= 3) { icon = 'partly_cloudy_day'; desc = 'Cloudy'; bgClass = 'cloudy'; }
            if (code >= 51 && code <= 67) { icon = 'rainy'; desc = 'Raining'; bgClass = 'rainy'; }
            if (code >= 95) { icon = 'thunderstorm'; desc = 'Storm'; bgClass = 'rainy'; }

            if (!isDay && code === 0) icon = 'bedtime';

            elements.weatherIcon.textContent = icon;
            elements.weatherDesc.textContent = desc;

            // Update Background Theme
            document.body.className = bgClass;

            // Simple Sun/Moon Visual
            elements.bgEffects.innerHTML = `<div class="sun-moon" style="background: ${isDay ? '#FFD54F' : '#E0E0E0'}; box-shadow: 0 0 ${isDay ? '60px #FFD54F' : '30px #E0E0E0'}"></div>`;
        }

        // --- Search Feature ---
        document.getElementById('searchBtn').addEventListener('click', async () => {
            const query = elements.searchInput.value;
            if(!query) return;

            // Show loader again
            document.getElementById('loadingScreen').style.display = 'flex';
            document.getElementById('loadingScreen').style.opacity = '1';
            animateLoader(); // Restart animation

            try {
                const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${query}&count=1`);
                const data = await res.json();
                if(data.results) {
                    const loc = data.results[0];
                    await fetchWeather(loc.latitude, loc.longitude, loc.name);
                } else {
                    alert("City not found");
                    stopLoader();
                }
            } catch(e) {
                stopLoader();
            }
        });

        // Start
        startApp();

    </script>
</body>
</html>
